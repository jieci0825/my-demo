# SSE 训练任务清单

## 阶段一：概念理解

### 任务 1.1 - 理解 SSE 是什么

- [ ] SSE 是一种基于 HTTP 的服务器单向推送技术
- [ ] 对比学习：SSE vs WebSocket vs 轮询
  - SSE：单向（服务端→客户端），基于 HTTP，自动重连
  - WebSocket：双向通信，需要独立协议
  - 轮询：客户端定时请求，浪费资源

### 任务 1.2 - 了解 SSE 协议格式

- [ ] 响应头：`Content-Type: text/event-stream`
- [ ] 掌握数据格式：
  ```
  data: 消息内容\n\n
  event: 自定义事件名\n
  data: 消息内容\n\n
  id: 消息ID\n
  data: 消息内容\n\n
  retry: 重连间隔(毫秒)\n\n
  ```

---

## 阶段二：基础实践

### 任务 2.1 - 实现最简单的 SSE 服务端

- [ ] 创建一个 Node.js 服务端
- [ ] 设置正确的响应头
- [ ] 每秒向客户端发送当前时间
- [ ] 持续 10 秒后关闭连接

### 任务 2.2 - 实现 SSE 客户端

- [ ] 使用浏览器原生 `EventSource` API
- [ ] 连接服务端
- [ ] 监听 `message` 事件并打印数据
- [ ] 处理 `open` 和 `error` 事件

### 任务 2.3 - 自定义事件类型

- [ ] 服务端发送不同类型的事件（如 `notification`、`update`）
- [ ] 客户端分别监听不同事件类型

---

## 阶段三：进阶功能

### 任务 3.1 - 实现消息 ID 和断线重连

- [ ] 服务端为每条消息添加 `id`
- [ ] 客户端断线后重连时通过 `Last-Event-ID` 请求头恢复
- [ ] 服务端根据 ID 发送漏掉的消息

### 任务 3.2 - 实现心跳保活

- [ ] 服务端定期发送注释消息（`: heartbeat\n\n`）防止连接超时
- [ ] 理解为什么需要心跳机制

### 任务 3.3 - 多客户端广播

- [ ] 服务端维护连接池
- [ ] 实现向所有已连接客户端广播消息的能力
- [ ] 处理客户端断开时的清理逻辑

---

## 阶段四：实战项目

### 任务 4.1 - 实时通知系统

- [ ] 场景：模拟后台管理系统的实时通知推送
- [ ] 用户打开页面后订阅通知
- [ ] 服务端可推送不同类型通知（成功/警告/错误）
- [ ] 前端展示通知列表

### 任务 4.2 - 实时日志查看器

- [ ] 场景：类似 `tail -f` 的日志实时查看
- [ ] 服务端监听日志文件变化
- [ ] 新日志内容实时推送到客户端
- [ ] 支持暂停/继续接收

### 任务 4.3 - AI 流式输出（类 ChatGPT 效果）

- [ ] 场景：模拟 AI 对话的逐字输出效果
- [ ] 客户端发送问题
- [ ] 服务端通过 SSE 逐字/逐词返回回答
- [ ] 前端实现打字机效果

---

## 阶段五：生产级考量

### 任务 5.1 - 研究生产环境问题

- [ ] 浏览器对同域名 SSE 连接数的限制（HTTP/1.1 约 6 个）
- [ ] 如何通过 HTTP/2 或不同域名解决
- [ ] Nginx/负载均衡器的超时配置
- [ ] 如何优雅关闭连接

### 任务 5.2 - 对比 fetch + ReadableStream

- [ ] 使用 `fetch` API 的流式读取作为 SSE 的替代方案
- [ ] 对比两种方式的优劣

---

## 建议实践顺序

| 顺序 | 任务        | 预期产出                       |
| ---- | ----------- | ------------------------------ |
| 1    | 2.1 + 2.2   | 能跑通最基础的 SSE 通信        |
| 2    | 2.3         | 理解自定义事件机制             |
| 3    | 3.1         | 理解断线重连和消息恢复         |
| 4    | 3.2 + 3.3   | 掌握服务端连接管理             |
| 5    | 4.3         | 完成一个有实际价值的应用       |
| 6    | 5.1 + 5.2   | 了解生产环境注意事项           |
